<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding favicon -->
    

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    

    <!-- Adding overlay style-->
    


    <title>
      index.js
    </title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-light.css">
    
    <svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path
                    d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z" />
                <path
                    d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z" />
            </g>
        </symbol>
        <symbol id='search-icon' viewBox="0 0 512 512">
            <g>
                <g>
                    <path
                        d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z" />
                </g>
            </g>
            <g>
                <g>
                    <path
                        d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z" />
                </g>
            </g>
        </symbol>
        <symbol id="down-icon" viewBox="0 0 16 16">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd" 
                d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"
            >
            </path>
        </symbol>
    </defs>
</svg>
  </head>

  <body>

    <nav class="navbar" id="navbar">
      <div class="navbar-heading" id="navbar-heading"><a href="index.html"><h2 class="navbar-heading-text">Home</h2></a></div><div class="search-box" id="search-box"><div class="search-box-input-container"><input class="search-box-input" type="text" placeholder="Search..." id="search-box-input" /><svg class="search-icon" alt="search-icon"><use xlink:href="#search-icon"></use></svg></div><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-main-content" id="sidebar-main-content"><div class="accordion collapsed" id="8524812" > <h3 class="accordion-heading">Classes<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion collapsed child" id=9816114><div class="accordion-heading child"><a href="Graphistry.html">Graphistry</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Graphistry.html#.addColumns">addColumns</a></li><li data-type='method'><a href="Graphistry.html#.addExclusion">addExclusion</a></li><li data-type='method'><a href="Graphistry.html#.addFilter">addFilter</a></li><li data-type='method'><a href="Graphistry.html#.autocenter">autocenter</a></li><li data-type='method'><a href="Graphistry.html#.encodeAxis">encodeAxis</a></li><li data-type='method'><a href="Graphistry.html#.encodeIcons">encodeIcons</a></li><li data-type='method'><a href="Graphistry.html#.encodeSize">encodeSize</a></li><li data-type='method'><a href="Graphistry.html#.getCurrentWorkbook">getCurrentWorkbook</a></li><li data-type='method'><a href="Graphistry.html#.labelUpdates">labelUpdates</a></li><li data-type='method'><a href="Graphistry.html#.saveWorkbook">saveWorkbook</a></li><li data-type='method'><a href="Graphistry.html#.subscribeLabels">subscribeLabels</a></li><li data-type='method'><a href="Graphistry.html#.tickClustering">tickClustering</a></li><li data-type='method'><a href="Graphistry.html#.toggleHistograms">toggleHistograms</a></li><li data-type='method'><a href="Graphistry.html#.toggleInspector">toggleInspector</a></li><li data-type='method'><a href="Graphistry.html#.togglePanel">togglePanel</a></li><li data-type='method'><a href="Graphistry.html#.toggleTimebars">toggleTimebars</a></li><li data-type='method'><a href="Graphistry.html#.toogleToolbar">toogleToolbar</a></li><li data-type='method'><a href="Graphistry.html#.updateSetting">updateSetting</a></li><li data-type='method'><a href="Graphistry.html#.updateZoom">updateZoom</a></li><li data-type='method'><a href="Graphistry.html#subscribe">subscribe</a></li><li data-type='method'><a href="Graphistry.html#~encodeColor">encodeColor</a></li><li data-type='method'><a href="Graphistry.html#~lift">lift</a></li></ul></li><li class="accordion collapsed child" id=874508><div class="accordion-heading child"><a href="Observable.html">Observable</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Observable.html#subscribe">subscribe</a></li></ul></li><li class="accordion collapsed child" id=6229081><div class="accordion-heading child"><a href="Subscription.html">Subscription</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Subscription.html#unsubscribe">unsubscribe</a></li></ul></li></ul> </div><div class="accordion collapsed" id="5445352" > <h3 class="accordion-heading">Modules<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="module-GraphistryJS.html">GraphistryJS</a></li></ul> </div><div class="accordion collapsed" id="7745960" > <h3 class="accordion-heading">Global<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="global.html#LabelEvent">LabelEvent</a></li></ul> </div></div>
      

    </nav>
    <div class="navbar-ham" id="navbar-ham">
      <div>
        <div class="first"></div>
        <div class="second"></div>
        <div class="third"></div>
      </div>
    </div>

    <div id="main" class="main-content">
      
      <h1 id='page-title' class="page-title">
        index.js
      </h1>
      

      



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import shallowEqual from 'shallowequal';
import { Model } from '@graphistry/falcor-model-rxjs';
import { PostMessageDataSource } from '@graphistry/falcor-socket-datasource';
import { $ref, $atom, $value, $invalidate } from '@graphistry/falcor-json-graph';
import { $$observable, Subject, Scheduler, Observable, AsyncSubject, ReplaySubject } from './rxjs';


/**
 * @class Graphistry
 * @classdesc This object wraps a HTML IFrame of a Graphistry Visualization in order
 * to provide an API for interacting with the graph.
 * @extends Observable
 * @see {@link https://github.com/ReactiveX/rxjs/blob/master/doc/observable.md}
 */
class Graphistry extends Observable {

    /**
     * Create Graphistry {@link Observable} by extending observable's methods
     * @constructs Graphistry
     * @param {Object} source - The source observable.
     */
    constructor(source) {
        if (!source || typeof source === 'function' || typeof source !== 'object') {
            super(source);
        } else {
            super();
            if (typeof source[$$observable] === 'function') {
                this.source = source[$$observable]();
            } else {
                this.source = this.constructor.from(source);
            }
        }
    }

    /**
     * Creates a new {@link Observable} with this as the source, and the passed
     * operator as the new Observable's operator.
     * @method Graphistry~lift
     * @param {Operator} operator - the operator defining the operation to apply to the {@link Observable}
     * @return {@link Observable} a new {@link Observable} with the operator applied
     */
    lift(operator) {
        const observable = new Graphistry(this);
        observable.operator = operator;
        return observable;
    }

    /**
     * @private
     */
    static _getIds(componentType, name, dataType, values = []) {
        const { view } = this;
        return new this(view
            .call(`componentsByType['${componentType}'].rows.filter`, [name, dataType, values], ['_index'])
            .takeLast(1)
            .map(({ json = {} }) => {
                const { componentsByType = {} } = json;
                const { [componentType]: componentsForType = {} } = componentsByType;
                const { rows = {} } = componentsForType;
                return Array
                    .from(rows.filter || [])
                    .filter(Boolean).map(({ _index }) => _index);
            })
            .toPromise()
        );
    }
}

    /**
     * Add columns to the current graph visuzliation's dataset
     * @method Graphistry.addColumns
     * @params {...Arrays} columns - One of more columns to be appended to the dataset
     * @return {Graphistry&lt;Array&lt;Column>>} A {@link Graphistry} {@link Observable} that emits an Array of the new columns
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *     .flatMap(function(g) {
     *         window.g = g;
     *         const columns = [
     *             ['edge', 'highways', [66, 101, 280], 'number'],
     *             ['point', 'theme parks', ['six flags', 'disney world', 'great america'], 'string']
     *         ];
     *         console.log('adding columns', columns);
     *         return g.addColumns.apply(g, columns);
     *     })
     *     .subscribe();
     */
    Graphistry.addColumns = function (...columns) {
        const { view } = this;
        return new this(this
            .from(columns)
            .concatMap((column) => view.call('columns.add', column))
            .map(({ json: { columns }}) => columns).filter(Boolean)
            .map((columns) => columns[columns.length - 1].toJSON())
            .toArray()
            .toPromise()
        );
    }


    /**
     * Change colors based on an attribute. Pass null for attribute, mapping to clear.
     * @method Graphistry~encodeColor
     * @param {GraphType} [graphType] - 'point' or 'edge'
     * @param {Attribute} [attribute] - name of data column, e.g., 'degree'
     * @param {Variant} [variation] - If there are more bins than colors, use 'categorical' to repeat colors and 'continuous' to interpolate
     * @param {Array} [mapping] - array of color name or hex codes
     * @return {@link Graphistry} A {@link Graphistry} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .flatMap(function (g) {
     *         window.g = g;
     *         return g.encodeColor('point', 'degree', 'categorical', ['black', 'white'])
     *     })
     *     .subscribe();
     */
     Graphistry.encodeColor = function (graphType, attribute, variation, mapping) {
        const { view } = this;
        return new this(view.set(
            $value(`encodings.${graphType}.color`,
                {   reset: attribute === undefined, variation, name: 'user_' + Math.random(),
                    encodingType: 'color', graphType, attribute, mapping }))
            .map(({ json }) => json.toJSON())
            .toPromise());
    }
    //helper just for react bindings
    // undefined (reset)
    // str (attr)
    // str, str, array (attr, variation, mapping)
    Graphistry.encodePointColor = function (opts) {
        const args = ['point'];
        if (opts !== undefined) {
            if (opts instanceof Array) {
                for (let v of opts) {
                    args.push(v);
                }
            } else if (typeof(opts) === 'string') {
                args.push(opts);
            }
        }
        return this.encodeColor.apply(this, args);
     }
    //helper just for react bindings
    // undefined (reset)
    // str (attr)
    // str, str, array (attr, variation, mapping)
    Graphistry.encodeEdgeColor = function (opts) {
        const args = ['edge'];
        if (opts !== undefined) {
            if (opts instanceof Array) {
                for (let v of opts) {
                    args.push(v);
                }
            } else if (typeof(opts) === 'string') {
                args.push(opts);
            }
        }
        return this.encodeColor.apply(this, args);
     }


    /**
     * Change axis
     * @method Graphistry.encodeAxis
     * @param {Array} array of strings
     * @return {@link Graphistry} A {@link Graphistry} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .flatMap(function (g) {
     *         window.g = g;
     *         return g.encodeAxis({})
     *     })
     *     .subscribe();
     */
     Graphistry.encodeAxis = function (axis) {
        const { view } = this;

        return new this(view.set(
            $value(`encodings.point.axis`,
                {   reset: axis === undefined, name: 'user_' + Math.random(),
                    encodingType: 'axis', graphType: 'point', attribute: 'degree', variation: 'categorical',
                    rows: axis }))
            .map(({ json }) => json.toJSON())
            .toPromise());
    }



    /**
     * Change icons based on an attribute. Pass undefined for attribute, mapping to clear.
     * @method Graphistry.encodeIcons
     * @param {GraphType} [graphType] - 'point' or 'edge'
     * @param {Attribute} [attribute] - name of data column, e.g., 'icon'
     * @param {Mapping} [object] - optional value mapping, e.g., {categorical: {fixed: {ip: 'laptop', alert: 'alaram'}, other: 'question'}}
     * @return {@link Graphistry} A {@link Graphistry} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .flatMap(function (g) {
     *         window.g = g;
     *         return g.encodeIcons('point', 'icon')
     *     })
     *     .subscribe();
     */
     Graphistry.encodeIcons = function (graphType, attribute, mapping) {
        const { view } = this;
        return new this(view.set(
            $value(`encodings.${graphType}.icon`,
                {   reset: attribute === undefined, name: 'user_' + Math.random(),
                    encodingType: 'icon', graphType, attribute, mapping }))
            .map(({ json }) => json.toJSON())
            .toPromise());
    }
    //helper just for react bindings
    // undefined (reset)
    // str (attr)
    // str, array (attr, mapping)
    Graphistry.encodePointIcons = function (opts) {
        const args = ['point'];
        if (opts !== undefined) {
            if (opts instanceof Array) {
                for (let v of opts) {
                    args.push(v);
                }
            } else if (typeof(opts) === 'string') {
                args.push(opts);
            }
        }
        return this.encodeIcons.apply(this, args);
     }
    //helper just for react bindings
    // undefined (reset)
    // str (attr)
    // str, array (attr, mapping)
    Graphistry.encodeEdgeIcons = function (opts) {
        const args = ['edge'];
        if (opts !== undefined) {
            if (opts instanceof Array) {
                for (let v of opts) {
                    args.push(v);
                }
            } else if (typeof(opts) === 'string') {
                args.push(opts);
            }
        }
        return this.encodeIcons.apply(this, args);
     }

    /**
     * Change size based on an attribute. Pass null for attribute, mapping to clear.
     * @method Graphistry.encodeSize
     * @param {GraphType} [graphType] - 'point'
     * @param {Attribute} [attribute] - name of data column, e.g., 'degree'
     * @return {@link Graphistry} A {@link Graphistry} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .flatMap(function (g) {
     *         window.g = g;
     *         return g.encodeSize('point', 'community_infomap')
     *     })
     *     .subscribe();
     */
     Graphistry.encodeSize = function (graphType, attribute, mapping) {
        const { view } = this;
        return new this(view.set(
            $value(`encodings.${graphType}.size`,
                {   reset: attribute === undefined, name: 'user_' + Math.random(),
                    encodingType: 'size', graphType, attribute, mapping }))
            .map(({ json }) => json.toJSON())
            .toPromise());
    }

    //helper just for react bindings
    // undefined (reset)
    // str (attr)
    // [str, obj] (attr, mapping)
    Graphistry.encodePointSize = function (opts) {
        const args = ['point'];
        if (opts !== undefined) {
            const attribute = opts instanceof Array ? opts[0] : opts;
            args.push(attribute);
            if (opts instanceof Array &amp;&amp; opts.length > 1) {
                const mapping = opts[1];
                args.push(mapping);
            }
        }
        return this.encodeSize.apply(this, args);
     }


    /**
     * Toggle a leftside panel
     * @method Graphistry.togglePanel
     * @param {string} [panel] - Name of panel: filters, exclusions, scene, labels, layout
     * @param {boolean} [turnOn] - Whether to make panel visible, or turn all off
     * @return {@link Graphistry} A {@link Graphistry} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .flatMap(function (g) {
     *         window.g = g;
     *         console.log('opening filters');
     *         return g.togglePanel('filters', true);
     *     })
     *     .subscribe();
     */
     Graphistry.togglePanel = function (panel, turnOn) {
        const { view } = this;
        if (turnOn) {
            return new this(view.set(
                $value(`filters.controls[0].selected`, panel === 'filters'),
                $value(`scene.controls[1].selected`, panel === 'scene'),
                $value(`labels.controls[0].selected`, panel === 'labels'),
                $value(`layout.controls[0].selected`, panel === 'layout'),
                $value(`exclusions.controls[0].selected`, panel === 'exclusions'),
                $value(`panels.left`,
                    panel === 'filters' ? $ref(view._path.concat(`filters`))
                    : panel === 'scene' ? $ref(view._path.concat(`scene`))
                    : panel === 'labels' ? $ref(view._path.concat(`labels`))
                    : panel === 'layout' ? $ref(view._path.concat(`layout`))
                    : $ref(view._path.concat(`exclusions`)))
            )
            .map(({ json }) => json.toJSON())
            .toPromise());
        } else {
            return new this(view.set(
                $value(`panels.left`, undefined),
                $value(`filters.controls[0].selected`, false),
                $value(`scene.controls[1].selected`, false),
                $value(`labels.controls[0].selected`, false),
                $value(`layout.controls[0].selected`, false),
                $value(`exclusions.controls[0].selected`, false)
            )
            .map(({ json }) => json.toJSON())
            .toPromise());
        }
    }

    Graphistry.encodeDefaultIcons = function (graphType, attribute, mapping) {
        const { view } = this;
        return new this(view.set(
            $value(`encodings.defaults.${graphType}.icon`,
                {   reset: attribute === undefined, name: 'user_' + Math.random(),
                    encodingType: 'icon', graphType, attribute, mapping }))
            .map(({ json }) => json.toJSON())
            .toPromise());
    }
    //helper just for react bindings
    // undefined (reset)
    // str (attr)
    // [str, obj] (attr, mapping)
    Graphistry.encodeDefaultPointIcons = function (opts) {
        const args = ['point'];
        if (opts !== undefined) {
            const attribute = opts instanceof Array ? opts[0] : opts;
            args.push(attribute);
            if (opts instanceof Array &amp;&amp; opts.length > 1) {
                const mapping = opts[1];
                args.push(mapping);
            }
        }
        return this.encodeDefaultIcons.apply(this, args);
    }
    //helper just for react bindings
    // undefined (reset)
    // str (attr)
    // [str, obj] (attr, mapping)
    Graphistry.encodeDefaultEdgeIcons = function(opts) {
        const args = ['edge'];
        if (opts !== undefined) {
            const attribute = opts instanceof Array ? opts[0] : opts;
            args.push(attribute);
            if (opts instanceof Array &amp;&amp; opts.length > 1) {
                const mapping = opts[1];
                args.push(mapping);
            }
        }
        return this.encodeDefaultIcons.apply(this, args);
    }

    Graphistry.encodeDefaultSize = function(graphType, attribute, mapping) {
        const { view } = this;
        return new this(view.set(
            $value(`encodings.defaults.${graphType}.size`,
                {   reset: attribute === undefined, name: 'user_' + Math.random(),
                    encodingType: 'size', graphType, attribute, mapping }))
            .map(({ json }) => json.toJSON())
            .toPromise());
    }
    //helper just for react bindings
    // undefined (reset)
    // str (attr)
    // [str, obj] (attr, mapping)
    Graphistry.encodeDefaultPointSize = function(opts) {
        const args = ['point'];
        if (opts !== undefined) {
            const attribute = opts instanceof Array ? opts[0] : opts;
            args.push(attribute);
            if (opts instanceof Array &amp;&amp; opts.length > 1) {
                const mapping = opts[1];
                args.push(mapping);
            }
        }
        return this.encodeDefaultSize.apply(this, args);
    }
    //helper just for react bindings
    // undefined (reset)
    // str (attr)
    // [str, obj] (attr, mapping)
    Graphistry.encodeDefaultEdgeSize = function(opts) {
        const args = ['edge'];
        if (opts !== undefined) {
            const attribute = opts instanceof Array ? opts[0] : opts;
            args.push(attribute);
            if (opts instanceof Array &amp;&amp; opts.length > 1) {
                const mapping = opts[1];
                args.push(mapping);
            }
        }
        return this.encodeDefaultSize.apply(this, args);
    }

    Graphistry.encodeDefaultColor = function (graphType, attribute, variation, mapping) {
        const { view } = this;
        return new this(view.set(
            $value(`encodings.defaults.${graphType}.color`,
                {   reset: attribute === undefined, variation, name: 'user_' + Math.random(),
                    encodingType: 'color', graphType, attribute, mapping }))
            .map(({ json }) => json.toJSON())
            .toPromise());
    }  
    //helper just for react bindings
    // undefined (reset)
    // str (attr)
    // [str, obj] (attr, mapping)
    Graphistry.encodeDefaultPointColor = function (opts) {
        const args = ['point'];
        if (opts !== undefined) {
            const attribute = opts instanceof Array ? opts[0] : opts;
            args.push(attribute);
            if (opts instanceof Array &amp;&amp; opts.length > 1) {
                const mapping = opts[1];
                args.push(mapping);
            }
        }
        return this.encodeDefaultColor.apply(this, args);
    }
    //helper just for react bindings
    // undefined (reset)
    // str (attr)
    // [str, obj] (attr, mapping)
    Graphistry.encodeDefaultEdgeColor = function (opts) {
        const args = ['edge'];
        if (opts !== undefined) {
            const attribute = opts instanceof Array ? opts[0] : opts;
            args.push(attribute);
            if (opts instanceof Array &amp;&amp; opts.length > 1) {
                const mapping = opts[1];
                args.push(mapping);
            }
        }
        return this.encodeDefaultColor.apply(this, args);
    }


    /**
     * Toggle inspector panel
     * @method Graphistry.toggleInspector
     * @param {boolean} [turnOn] - Whether to make panel visible
     * @return {@link Graphistry} A {@link Graphistry} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .flatMap(function (g) {
     *         window.g = g;
     *         console.log('opening inspector panel');
     *         return g.toggleInspector(true);
     *     })
     *     .subscribe();
     */
     Graphistry.toggleInspector = function (turnOn) {
        const { view } = this;
        if (!turnOn) {
            return new this(view.set(
                $value(`panels.bottom`, undefined),
                $value(`inspector.controls[0].selected`, false),
            )
            .map(({ json }) => json.toJSON())
            .toPromise());
        } else {
            return new this(view.set(
                $value(`inspector.controls[0].selected`, true),
                $value(`panels.bottom`, $ref(view._path.concat(`inspector`)))
            )
            .map(({ json }) => json.toJSON())
            .toPromise());
        }
    }

    /**
     * Toggle timebars panel
     * @method Graphistry.toggleTimebars
     * @param {boolean} [turnOn] - Whether to make panel visible
     * @return {@link Graphistry} A {@link Graphistry} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .flatMap(function (g) {
     *         window.g = g;
     *         console.log('opening timebards panel');
     *         return g.toggleTimebars(true);
     *     })
     *     .subscribe();
     */
     Graphistry.toggleTimebars = function (turnOn) {
        const { view } = this;
        if (!turnOn) {
            return new this(view.set(
                $value(`panels.bottom`, undefined),
                $value(`timebars.controls[0].selected`, false),
            )
            .map(({ json }) => json.toJSON())
            .toPromise());
        } else {
            return new this(view.set(
                $value(`timebars.controls[0].selected`, true),
                $value(`panels.bottom`, $ref(view._path.concat(`timebars`)))
            )
            .map(({ json }) => json.toJSON())
            .toPromise());
        }
    }

    /**
     * Toggle histogram panel
     * @method Graphistry.toggleHistograms
     * @param {boolean} [turnOn] - Whether to make panel visible
     * @return {@link Graphistry} A {@link Graphistry} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .flatMap(function (g) {
     *         window.g = g;
     *         console.log('opening histogram panel');
     *         return g.toggleHistograms(true);
     *     })
     *     .subscribe();
     */
     Graphistry.toggleHistograms = function (turnOn) {
        const { view } = this;
        if (!turnOn) {
            return new this(view.set(
                $value(`panels.right`, undefined),
                $value(`histograms.controls[0].selected`, false)
            )
            .map(({ json }) => json.toJSON())
            .toPromise());
        } else {
            return new this(view.set(
                $value(`histograms.controls[0].selected`, true),
                $value(`panels.right`, $ref(view._path.concat(`histograms`)))
            )
            .map(({ json }) => json.toJSON())
            .toPromise());
        }
    }

    /**
     * Run a number of steps of Graphistry's clustering algorithm
     * @method Graphistry.tickClustering
     * @static
     * @param {number} ticks - The number of ticks to run
     * @return {@link Graphistry} A {@link Graphistry} {@link Observable} that emits the result of the operation
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *     .flatMap(function (g) {
     *         window.g = g;
     *         console.log('starting to cluster');
     *         return g.tickClustering();
     *     })
     *     .subscribe();
     */
     Graphistry.tickClustering = function (ticks = 1) {

        let obs;
        const { view } = this;

        if (typeof ticks !== 'number') {
            obs = Observable.of({});
        } else {
            obs = Observable
                .timer(0, 40)
                .take(Math.abs(ticks) || 1)
                .concatMap(() => view.call('tick', []))
                .takeLast(1);
        }

        return new this(obs.toPromise());
    }

    /**
     * Center the view of the graph
     * @method Graphistry.autocenter
     * @todo Implement this function
     * @static
     * @param {number} percentile - Controls sensitivity to outliers
     * @param {function} [cb] - Callback function of type callback(error, result)
     * @return {@link Graphistry} A {@link Graphistry} {@link Observable} that emits the result of the operation
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *     .flatMap(function (g) {
     *         window.g = g;
     *         console.log('centering');
     *         return g.autocenter(.90);
     *     })
     *     .subscribe();
     */
     Graphistry.autocenter = function (percentile, cb) {

    }

    /**
     * Read the workbook ID
     * @method Graphistry.getCurrentWorkbook
     * @static
     * @param {function} [cb] - Callback function of type callback(error, result)
     * @return {@link Graphistry} A {@link Graphistry} {@link Observable} that emits the result of the operation
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *     .flatMap(function (g) {
     *         window.g = g;
     *         console.log('getting workbook id');
     *         return g.getCurrentWorkbook();
     *     })
     *     .subscribe(function (workbook) {
     *         alert('id: ' + workbook.id)
     *     });
     */
     Graphistry.getCurrentWorkbook = function () {
        const { workbook } = this;
         return new this(workbook.get('id')
            .map(({ json }) => json.toJSON())
            .toPromise());
    }

    /**
     * Save the current workbook. A saved workbook will persist the analytics state
     * of the visualization, including active filters and exclusions
     * @method Graphistry.saveWorkbook
     * @static
     * @return {@link Graphistry} A {@link Graphistry} {@link Observable} that emits the result of the operation
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *     .flatMap(function (g) {
     *         window.g = g;
     *         return g.saveWorkbook();
     *     })
     *     .subscribe();
     */
     Graphistry.saveWorkbook = function () {

        const { workbook } = this;

        return new this(workbook.call('save', [])
            .map(({ json }) => json.toJSON())
            .toPromise());
    }


    /**
     * Hide or Show Toolbar UI
     * @method Graphistry.toogleToolbar
     * @static
     * @param {boolean} show - Set to true to show toolbar, and false to hide toolbar.
     * @return {@link Graphistry} A {@link Graphistry} {@link Observable} that emits the result of the operation
     * @example
     *
     * &lt;button onclick="window.graphistry.toggleToolbar(false)">Hide toolbar&lt;/button>
     * &lt;button onclick="window.graphistry.toggleToolbar(true)">Show toolbar&lt;/button>
     *
     */
     Graphistry.toggleToolbar = function (show) {
        return this.updateSetting('showToolbar', !!show);
    }

    /**
     * Add a filter to the visualization with the given expression
     * @method Graphistry.addFilter
     * @static
     * @param {string} expr - An expression using the same language as our in-tool
     * exclusion and filter panel
     * @return {@link Graphistry} A {@link Graphistry} {@link Observable} that emits the result of the operation
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *     .flatMap(function (g) {
     *         window.g = g;
     *         console.log('Adding filter for "point:degree > 0"');
     *         return g.addFilter('point:degree > 0');
     *     })
     *     .subscribe();
     */
     Graphistry.addFilter = function (expr) {

        const { view } = this;

        return new this(view.call('filters.add', [expr])
            .map(({ json }) => json.toJSON())
            .toPromise());
    }
    Graphistry.addFilters = function (expr) {

        if (typeof(expr) === 'string') {
            return this.addFilter(expr);
        }

        let filtered = null;
        for (let e of expr) {
            if (filtered === null) {
                filtered = this.addFilter(e);
            } else {
                filtered = filtered.flatMap(() => this.addFilter(e));
            }
        }
        return filtered;
    }

    /**
     * Add an exclusion to the visualization with the given expression
     * @method Graphistry.addExclusion
     * @static
     * @param {string} expr - An expression using the same language as our in-tool
     * exclusion and filter panel
     * @return {@link Graphistry} A {@link Graphistry} {@link Observable} that emits the result of the operation
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *     .flatMap(function (g) {
     *         window.g = g;
     *         console.log('Adding exclusion for "point:degree > 0"');
     *         return g.addExclusion('point:degree > 0');
     *     })
     *     .subscribe();
     */
     Graphistry.addExclusion = function (expr) {
        const { view } = this;

        return new this(view.call('exclusions.add', [expr])
            .map(({ json }) => json.toJSON())
            .toPromise());
    }

    Graphistry.addExclusions = function (expr) {

        if (typeof(expr) === 'string') {
            return this.addExclusion(expr);
        }

        let filtered = null;
        for (let e of expr) {
            if (filtered === null) {
                filtered = this.addExclusion(e);
            } else {
                filtered = filtered.flatMap(() => this.addExclusion(e));
            }
        }
        return filtered;
    }

    /**
     * @description
     * Modify a settings value in the visualization
     *
     * | Available Settings | Value Type |
     * | ------------------ | ---------- |
     * | `showToolbar` | `boolean` |
     * | `pruneOrphans` | `boolean` |
     * | `showArrows` | `boolean` |
     * | `background` | color as hex or rgba `string` |
     * | `edgeOpacity` | `number` (0 to 1) |
     * | `edgeSize` | `number` (0.1 to 10) |
     * | `edgeCurvature` | `number` (0.1 to 1) |
     * | `pointOpacity` | `number` (0 to 1) |
     * | `pointSize` | `number` (0.1 to 10) |
     * | `zoom` | `uint` |
     * | `center` | `const 0` |
     * | `labelOpacity` | `boolean` |
     * | `labelEnabled` | `boolean` |
     * | `labelPOI` | `boolean` |
     * | `labelLabelPOI` | `boolean` |
     * | `labelHighlightEnabled` | `boolean` |
     * | `labelColor` | color as hex or rgba `string` |
     * | `labelBackground` | color as hex or rgba `string` |
     * | `precisionVsSpeed` | `int` (-5 to +5) |
     * | `dissuadeHubs` | `boolean` | 
     * | `lockedX` | `boolean` | 
     * | `lockedY` | `boolean` | 
     * | `lockedR` | `boolean` | 
     * @method Graphistry.updateSetting
     * @static
     * @param {string} name - the name of the setting to change
     * @param {string} val - the value to set the setting to.
     * @return {@link Graphistry} A {@link Graphistry} {@link Observable} that emits the result of the operation
     */
     Graphistry.updateSetting = function (name, val) {

        const lookup = {

            //models/toolbar.js
            'showToolbar': ['view', 'toolbar.visible'],

            //models/scene/scene.js
            'pruneOrphans': ['view', 'pruneOrphans'],
            'showArrows':   ['view', 'scene.renderer.showArrows'],
            'background':   ['view', 'scene.renderer.background.color'],
            'edgeOpacity':  ['view', 'scene.renderer.edges.opacity'],
            'edgeSize':     ['view', 'scene.renderer.edges.scaling'],
            'edgeCurvature': ['view', 'scene.renderer.edges.curvature'],
            'pointOpacity': ['view', 'scene.renderer.points.opacity'],
            'pointSize':    ['view', 'scene.renderer.points.scaling'],

            //models/camera.js
            'zoom':   ['view', 'camera.zoom'],
            'center': ['view', 'camera.center["x", "y", "z"]'],

            //models/label.js
            'labelOpacity':          ['view', 'labels.opacity'],
            'labelEnabled':          ['view', 'labels.enabled'],
            'labelPropertiesEnabled': ['view', 'labels.propertiesEnabled'],
            'labelPOI':              ['view', 'labels.poiEnabled'],
            'labelLabelPOI':              ['view', 'labels.poiLabelEnabled'],
            'labelPOIMax':           ['view', 'labels.poiMax'],
            'labelHighlightEnabled': ['view', 'labels.highlightEnabled'],
            'labelColor':            ['view', 'labels.foreground.color'],
            'labelBackground':       ['view', 'labels.background.color'],

            //models/layout.js
            'precisionVsSpeed': ['view', 'layout.options.forceatlas2barnes[0].value'],
            'gravity':          ['view', 'layout.options.forceatlas2barnes[1].value'],
            'scalingRatio':     ['view', 'layout.options.forceatlas2barnes[2].value'],
            'edgeInfluence':    ['view', 'layout.options.forceatlas2barnes[3].value'],
            'strongGravity':    ['view', 'layout.options.forceatlas2barnes[4].value'],
            'dissuadeHubs':     ['view', 'layout.options.forceatlas2barnes[5].value'],
            'linLog':           ['view', 'layout.options.forceatlas2barnes[6].value'],
            'lockedX':          ['view', 'layout.options.forceatlas2barnes[7].value'],
            'lockedY':          ['view', 'layout.options.forceatlas2barnes[8].value'],
            'lockedR':          ['view', 'layout.options.forceatlas2barnes[9].value'],
        };

        const [model, path] = lookup[name];

        return new this(this[model]
            .set($value(path, $atom(val, { $timestamp: Date.now() })))
            .map(({ json }) => json.toJSON())
            .toPromise());
    }

    /**
     * Update the camera zoom level
     * @method Graphistry.updateZoom
     * @static
     * @param {number} level - Controls how far to zoom in or out.
     * @param {string} val - the value to set the setting to.
     * @return {@link Graphistry} A {@link Graphistry} {@link Observable} that emits the result of the operation
     */
     Graphistry.updateZoom = function (level) {
        return this.updateSetting('zoom', level);
    }

    /**
     * Get or create an {@link Observable} stream of all label updates from the visualization.
     * &lt;p>
     * The {@link Observable} returned by this method emits inner Observables, where each
     * inner {@link Observable} is tied to the lifetime of the label for which it was created.
     * &lt;/p>&lt;p>
     * For each label rendered in the visualization, the {@link Observable} returned by this
     * method will create and emit a new inner {@link Observable}. The inner {@link Observable} will
     * emit events when the label changes. For example, if the user clicks on the label,
     * or the label changes position because of a pan/zoom, the inner {@link Observable} will
     * emit an event.
     * &lt;/p>&lt;p>
     * The inner {@link Observable} for a label will complete if the label is removed from the screen.
     * &lt;/p>&lt;p>
     * @method Graphistry.labelUpdates
     * @static
     * @return {Observable&lt;Observable&lt;LabelEvent>>} An {@link Observable} of inner {Observables}, where each
     * inner {@link Observable} represents the lifetime of a label in the visualization.
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *     .flatMap(function (g) {
     *         window.g = g;
     *         console.log('Listening for label updates');
     *         return g.labelUpdates();
     *     })
     *     .flatMap(function (labelUpdates) {
     *         return labelUpdates
     *             .do(function ({ id, tag, pageX, pageY }) {
     *                 // prints messages like
     *                 // > 'Label 13 added at (200, 340)'
     *                 // > 'Label 74 updated at (750, 100)'
     *                 console.log(`Label ${id} ${tag} at (${pageX}, ${pageY})`);
     *             })
     *             .takeLast(1)
     *             .do(function ({ id, pageX, pageY }) {
     *                 console.log(`Label ${id} removed at (${pageX}, ${pageY})`);
     *             });
     *     })
     *     .subscribe();
     */
     Graphistry.labelUpdates = function () {
        return this.labelsStream || (this.labelsStream = this
            .fromEvent(window, 'message')
            .pluck('data')
            .filter((data) => data &amp;&amp; data.type === 'labels-update')
            .multicast(() => new ReplaySubject(1))
            .let((connectable) => connectable.connect() &amp;&amp; connectable.refCount())
            .scan((memo, { labels, simulating, semanticZoomLevel }) => {

                labels = labels || [];
                const updates = [], newSources = [];
                const labelsById = Object.create(null);
                const nextSources = Object.create(null);
                const { sources, prevLabelsById } = memo;
                let idx = -1, len = labels.length, label;

                while (++idx &lt; len) {
                    let source;
                    label = labels[idx];
                    const { id } = label;

                    if (id in sources) {
                        source = sources[id];
                        delete sources[id];
                        if (memo.simulating !== simulating ||
                            memo.semanticZoomLevel !== semanticZoomLevel ||
                            !shallowEqual(prevLabelsById[id], label)) {
                            updates.push({ ...label, simulating, semanticZoomLevel, tag: 'updated' });
                        }
                    } else {
                        newSources.push(source = new ReplaySubject(1));
                        updates.push({ ...label, simulating, semanticZoomLevel, tag: 'added' });
                        source.key = id;
                    }

                    labelsById[id] = label;
                    nextSources[id] = source;
                }

                for (const id in sources) {
                    sources[id].complete();
                }

                idx = -1;
                len = updates.length;
                while (++idx &lt; len) {
                    label = updates[idx];
                    nextSources[label.id].next(label);
                }

                return {
                    newSources,
                    simulating,
                    semanticZoomLevel,
                    sources: nextSources,
                    prevLabelsById: labelsById
                };
            }, {
                newSources: [],
                sources: Object.create(null),
                prevLabelsById: Object.create(null),
            })
            .mergeMap(({ newSources }) => newSources)
        );
    }

    /**
     * Subscribe to label change and exit events
     * @method Graphistry.subscribeLabels
     * @static
     * @param {Object} - An Object with `onChange` and `onExit` callbacks
     * @return {Subscription} A {@link Subscription} that can be used to stop reacting to label updates
     */
     Graphistry.subscribeLabels = function ({ onChange, onExit }) {
        return this.labelUpdates().mergeMap((group) => group
            .do((event) => onChange &amp;&amp; onChange(event))
            .takeLast(1)
            .do((event) => onExit &amp;&amp; onExit(event))
        )
        .subscribe();
    }

Graphistry.view = null;
Graphistry.model = null;
Graphistry.workbook = null;

/**
 * Function that creates a Graphistry Wrapped IFrame - see class {@link Graphistry} for returned API
 * @func GraphistryJS
 * @exports module:Graphistry
 * @param {Object} IFrame - An IFrame that hosts a Graphistry visualization.
 * @return {@link Graphistry}
 * @example
 *
 * &lt;iframe id="viz" src="https://hub.graphistry.com/graph/graph.html?dataset=Miserables" />
 * &lt;script>
 * document.addEventListener("DOMContentLoaded", function () {
 *
 *     GraphistryJS(document.getElementById('viz'))
 *         .flatMap(function (g) {
 *             window.g = g;
 *             document.getElementById('controls').style.opacity=1.0;
 *             console.log('opening filters');
 *             return g.openFilters();
 *         })
 *         .delay(5000)
 *         .flatMap(function() {
 *             console.log('filters opened');
 *             const columns = [
 *                 ['edge', 'highways', [66, 101, 280], 'number'],
 *                 ['point', 'theme parks', ['six flags', 'disney world', 'great america'], 'string']
 *             ];
 *             console.log('adding columns', columns);
 *             return g.addColumns.apply(g, columns);
 *        })
 *         .subscribe(function (result) {
 *             console.log('all columns: ', result);
 *         });
 * });
 * &lt;/script>
 *
 */
function GraphistryJS(iFrame) {

    if (!iFrame) {
        throw new Error('No iframe provided to Graphistry');
    }

    return Graphistry
        .fromEvent(iFrame, 'load', ({ target }) => target)
        .startWith(iFrame) // say hello first and on each load
        .map((target) => target.contentWindow)
        .do((target) => target &amp;&amp; target.postMessage &amp;&amp; (
            console.log(`Graphistry API: connecting to client`) ||
            target.postMessage({
                type: 'ready', agent: 'graphistryjs'
            }, '*'))
        )
        .switchMap(
            (target) => Graphistry
                .fromEvent(window, 'message')
                .filter(({ data }) => data &amp;&amp; data.type === 'init' &amp;&amp; data.cache),
            (target, { cache }) => ({ target, cache })
        )
        .switchMap(({ target, cache }) => {

            const model = new Model({
                cache,
                recycleJSON: true,
                scheduler: Scheduler.async,
                allowFromWhenceYouCame: true
            });

            model._source = new PostMessageDataSource(window, target, model, '*');

            class InstalledGraphistry extends Graphistry {
                lift(operator) {
                    const observable = new InstalledGraphistry(this);
                    observable.operator = operator;
                    return observable;
                }
            }
            InstalledGraphistry.model = model;

            InstalledGraphistry = wrapStaticObservableMethods(Observable, InstalledGraphistry);

            return model.get(`workbooks.open.views.current.id`).map(({ json }) => {
                InstalledGraphistry.workbook = model.deref(json.workbooks.open);
                InstalledGraphistry.view = model.deref(json.workbooks.open.views.current);
                console.log(`Graphistry API: connected to client`);
                return InstalledGraphistry;
            });
        })
        .multicast(() => new ReplaySubject(1))
        .refCount();
}

Graphistry = wrapStaticObservableMethods(Observable, Graphistry);

GraphistryJS.Subject = Subject;
GraphistryJS.Scheduler = Scheduler;
GraphistryJS.Observable = Observable;
GraphistryJS.AsyncSubject = AsyncSubject;
GraphistryJS.ReplaySubject = ReplaySubject;
GraphistryJS.$$observable = $$observable;

export { GraphistryJS };

function wrapStaticObservableMethods(Observable, Graphistry) {
    function createStaticWrapper(staticMethodName) {
        return function(...args) {
            return new Graphistry(Observable[staticMethodName](...args));
        }
    }
    for (const staticMethodName in Observable) {
        Graphistry[staticMethodName] = createStaticWrapper(staticMethodName);
    }
    Graphistry.bindCallback = (...args) => (...args2) => new Graphistry(Observable.bindCallback(...args)(...args2));
    Graphistry.bindNodeCallback = (...args) => (...args2) => new Graphistry(Observable.bindNodeCallback(...args)(...args2));
    return Graphistry;
}

//esbuild not exposing some reason
try {
    window.GraphistryJS = GraphistryJS;
} catch (e) {
    //not browser
}

/**
 * A LabelEvent is dispatched by the inner Observables emitted by the labelUpdates() {@link Observable}.
 * A LabelEvent is generated for each label update in the visualization.
 * @typedef {Object} LabelEvent
 * @property {number} id - the integer ID for the element the label describes
 * @property {String} tag - a string that describes the update kind, either 'added' or 'updated'
 * @property {String} type - the graph component type for the element the label describes, either 'edge' or 'point'
 * @property {number} size - the size in pixels of the element the label describes. This is 0 for edges, and the diameter for points
 * @property {number} pageX - the pageX of the element the label describes
 * @property {number} pageY - the pageY of the element the label describes
 * @property {boolean} selected - a boolean that describes whether element the label describes is selected
 * @property {boolean} highlight - a boolean that describes whether element the label describes is highlighted
 * @property {boolean} simulating - a boolean that indicates the visualization is running clustering
 * @property {number} semanticZoomLevel - the semantic zoom level of the visualization
 */

/**
 * @constructor Observable
 * @see {@link https://github.com/ReactiveX/rxjs/blob/master/doc/observable.md}
 */

 /**
 * The subscribe method triggers the execution of the {@link Observable}, causing the values within to be pushed to a callback. An {@link Observable} is like a pipe of water that is closed. When subscribe is called, we open the valve and the values within are pushed at us.  These values can be received using either callbacks or an {@link Observer} object.
 * @name subscribe
 * @memberof Observable.prototype
 * @function
 * @arg {?Observable~nextCallback} next a callback that accepts the next value in the stream of values
 * @arg {?Observable~errorCallback} error a callback that accepts an error that occurred while evaluating the operation underlying the {@link Observable} stream
 * @arg {?Observable~completeCallback} completed a callback that is invoked when the {@link Observable} stream has ended, and the {@link Observable~nextCallback} will not receive any more values
 * @return {Subscription}
 */

/**
 * This callback accepts a value that was emitted while evaluating the operation underlying the {@link Observable} stream.
 * @callback Observable~nextCallback
 * @param {Object} value the value that was emitted while evaluating the operation underlying the {@link Observable}
 */

/**
 * This callback accepts an error that occurred while evaluating the operation underlying the {@link Observable} stream. When this callback is invoked, the {@link Observable} stream ends and no more values will be received by the {@link Observable~nextCallback}.
 * @callback Observable~errorCallback
 * @param {Error} error the error that occurred while evaluating the operation underlying the {@link Observable}
 */

 /**
 * This callback is invoked when the {@link Observable} stream ends. When this callback is invoked the {@link Observable} stream has ended, and therefore the {@link Observable~nextCallback} will not receive any more values.
 * @callback Observable~completeCallback
 */

/**
 * @constructor Subscription
 * @see {@link https://github.com/ReactiveX/rxjs/blob/master/doc/subscription.md}
 */

/**
 * When this method is called on the Subscription, the {@link Observable} that created the Subscription will stop sending values to the callbacks passed when the Subscription was created.
 * @name unsubscribe
 * @method
 * @memberof Subscription.prototype
 */
</code></pre>
        </article>
    </section>




    </div>

    <footer class="footer" id="footer">
      
    </footer>

    <script src="scripts/third-party/prettify.js"></script>
    <script src="scripts/third-party/lang-css.js"></script>
    <script type="text/javascript" src="scripts/misc.js"></script>

    <script>prettyPrint();</script>
    <script src="scripts/linenumber.js"></script>
    <script src="scripts/fix-code-block.js"></script>
    <script src="scripts/fix-navbar.js"></script>
    
      <script src="scripts/search.js"></script>
      <script src="scripts/third-party/fuse.js"></script>
      <script>
        var list = [{"title":"Graphistry","link":"<a href=\"Graphistry.html\">Graphistry</a>"},{"title":"Graphistry.addColumns","link":"<a href=\"Graphistry.html#.addColumns\">Graphistry.addColumns &rtrif; undefined</a>"},{"title":"Graphistry.addExclusion","link":"<a href=\"Graphistry.html#.addExclusion\">Graphistry.addExclusion &rtrif; undefined</a>"},{"title":"Graphistry.addFilter","link":"<a href=\"Graphistry.html#.addFilter\">Graphistry.addFilter &rtrif; undefined</a>"},{"title":"Graphistry.autocenter","link":"<a href=\"Graphistry.html#.autocenter\">Graphistry.autocenter &rtrif; undefined</a>"},{"title":"Graphistry.encodeAxis","link":"<a href=\"Graphistry.html#.encodeAxis\">Graphistry.encodeAxis &rtrif; undefined</a>"},{"title":"Graphistry.encodeIcons","link":"<a href=\"Graphistry.html#.encodeIcons\">Graphistry.encodeIcons &rtrif; undefined</a>"},{"title":"Graphistry.encodeSize","link":"<a href=\"Graphistry.html#.encodeSize\">Graphistry.encodeSize &rtrif; undefined</a>"},{"title":"Graphistry.getCurrentWorkbook","link":"<a href=\"Graphistry.html#.getCurrentWorkbook\">Graphistry.getCurrentWorkbook &rtrif; undefined</a>"},{"title":"Graphistry.labelUpdates","link":"<a href=\"Graphistry.html#.labelUpdates\">Graphistry.labelUpdates &rtrif; undefined</a>"},{"title":"Graphistry.saveWorkbook","link":"<a href=\"Graphistry.html#.saveWorkbook\">Graphistry.saveWorkbook &rtrif; undefined</a>"},{"title":"Graphistry.subscribeLabels","link":"<a href=\"Graphistry.html#.subscribeLabels\">Graphistry.subscribeLabels &rtrif; undefined</a>"},{"title":"Graphistry.tickClustering","link":"<a href=\"Graphistry.html#.tickClustering\">Graphistry.tickClustering &rtrif; undefined</a>"},{"title":"Graphistry.toggleHistograms","link":"<a href=\"Graphistry.html#.toggleHistograms\">Graphistry.toggleHistograms &rtrif; undefined</a>"},{"title":"Graphistry.toggleInspector","link":"<a href=\"Graphistry.html#.toggleInspector\">Graphistry.toggleInspector &rtrif; undefined</a>"},{"title":"Graphistry.togglePanel","link":"<a href=\"Graphistry.html#.togglePanel\">Graphistry.togglePanel &rtrif; undefined</a>"},{"title":"Graphistry.toggleTimebars","link":"<a href=\"Graphistry.html#.toggleTimebars\">Graphistry.toggleTimebars &rtrif; undefined</a>"},{"title":"Graphistry.toogleToolbar","link":"<a href=\"Graphistry.html#.toogleToolbar\">Graphistry.toogleToolbar &rtrif; undefined</a>"},{"title":"Graphistry.updateSetting","link":"<a href=\"Graphistry.html#.updateSetting\">Graphistry.updateSetting &rtrif; undefined</a>"},{"title":"Graphistry.updateZoom","link":"<a href=\"Graphistry.html#.updateZoom\">Graphistry.updateZoom &rtrif; undefined</a>"},{"title":"Graphistry#subscribe","link":"<a href=\"Graphistry.html#subscribe\">Graphistry &rtrif; subscribe</a>"},{"title":"Graphistry~encodeColor","link":"<a href=\"Graphistry.html#~encodeColor\">Graphistry~encodeColor &rtrif; undefined</a>"},{"title":"Graphistry~lift","link":"<a href=\"Graphistry.html#~lift\">Graphistry~lift &rtrif; undefined</a>"},{"title":"Observable","link":"<a href=\"Observable.html\">Observable</a>"},{"title":"Observable#subscribe","link":"<a href=\"Observable.html#subscribe\">Observable &rtrif; subscribe</a>"},{"title":"Subscription","link":"<a href=\"Subscription.html\">Subscription</a>"},{"title":"Subscription#unsubscribe","link":"<a href=\"Subscription.html#unsubscribe\">Subscription &rtrif; unsubscribe</a>"},{"title":"GraphistryJS","link":"<a href=\"module-GraphistryJS.html\">GraphistryJS</a>"},{"title":"LabelEvent","link":"<a href=\"global.html#LabelEvent\">LabelEvent</a>"}];
        var options = 
          setupSearch(list, options)
      </script>
    

    

    

    

    


  </body>

</html>
