<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding favicon -->
    

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    

    <!-- Adding overlay style-->
    


    <title>
      index.js
    </title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-light.css">
    
    <svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path
                    d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z" />
                <path
                    d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z" />
            </g>
        </symbol>
        <symbol id='search-icon' viewBox="0 0 512 512">
            <g>
                <g>
                    <path
                        d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z" />
                </g>
            </g>
            <g>
                <g>
                    <path
                        d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z" />
                </g>
            </g>
        </symbol>
        <symbol id="down-icon" viewBox="0 0 16 16">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd" 
                d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"
            >
            </path>
        </symbol>
    </defs>
</svg>
  </head>

  <body>

    <nav class="navbar" id="navbar">
      <div class="navbar-heading" id="navbar-heading"><a href="index.html"><h2 class="navbar-heading-text">Home</h2></a></div><div class="search-box" id="search-box"><div class="search-box-input-container"><input class="search-box-input" type="text" placeholder="Search..." id="search-box-input" /><svg class="search-icon" alt="search-icon"><use xlink:href="#search-icon"></use></svg></div><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-main-content" id="sidebar-main-content"><div class="accordion collapsed" id="8715407" > <h3 class="accordion-heading">Modules<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="module-graphistryJS.html">graphistryJS</a></li></ul> </div><div class="accordion collapsed" id="4443085" > <h3 class="accordion-heading">Global<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="global.html#addExclusion">addExclusion</a></li><li class="accordion-list" id=""><a href="global.html#addExclusions">addExclusions</a></li><li class="accordion-list" id=""><a href="global.html#addFilter">addFilter</a></li><li class="accordion-list" id=""><a href="global.html">autocenter</a></li><li class="accordion-list" id=""><a href="global.html#encodeAxis">encodeAxis</a></li><li class="accordion-list" id=""><a href="global.html#encodeColor">encodeColor</a></li><li class="accordion-list" id=""><a href="global.html#encodeDefaultEdgeIcons">encodeDefaultEdgeIcons</a></li><li class="accordion-list" id=""><a href="global.html#encodeDefaultIcons">encodeDefaultIcons</a></li><li class="accordion-list" id=""><a href="global.html#encodeDefaultPointIcons">encodeDefaultPointIcons</a></li><li class="accordion-list" id=""><a href="global.html#encodeEdgeColor">encodeEdgeColor</a></li><li class="accordion-list" id=""><a href="global.html#encodeEdgeIcons">encodeEdgeIcons</a></li><li class="accordion-list" id=""><a href="global.html#encodeIcons">encodeIcons</a></li><li class="accordion-list" id=""><a href="global.html#encodePointColor">encodePointColor</a></li><li class="accordion-list" id=""><a href="global.html#encodePointIcons">encodePointIcons</a></li><li class="accordion-list" id=""><a href="global.html#encodePointSize">encodePointSize</a></li><li class="accordion-list" id=""><a href="global.html#encodeSize">encodeSize</a></li><li class="accordion-list" id=""><a href="global.html#getCurrentWorkbook">getCurrentWorkbook</a></li><li class="accordion-list" id=""><a href="global.html#labelUpdates">labelUpdates</a></li><li class="accordion-list" id=""><a href="global.html#makeCaller">makeCaller</a></li><li class="accordion-list" id=""><a href="global.html#makeCallerJSON">makeCallerJSON</a></li><li class="accordion-list" id=""><a href="global.html#makeGetter">makeGetter</a></li><li class="accordion-list" id=""><a href="global.html#makeGetterJSON">makeGetterJSON</a></li><li class="accordion-list" id=""><a href="global.html#makeSetter">makeSetter</a></li><li class="accordion-list" id=""><a href="global.html#makeSetterWithModel">makeSetterWithModel</a></li><li class="accordion-list" id=""><a href="global.html#saveWorkbook">saveWorkbook</a></li><li class="accordion-list" id=""><a href="global.html#subscribeLabels">subscribeLabels</a></li><li class="accordion-list" id=""><a href="global.html#toggleHistograms">toggleHistograms</a></li><li class="accordion-list" id=""><a href="global.html#toggleInspector">toggleInspector</a></li><li class="accordion-list" id=""><a href="global.html#togglePanel">togglePanel</a></li><li class="accordion-list" id=""><a href="global.html#toggleTimebars">toggleTimebars</a></li><li class="accordion-list" id=""><a href="global.html#toogleToolbar">toogleToolbar</a></li><li class="accordion-list" id=""><a href="global.html#updateSetting">updateSetting</a></li><li class="accordion-list" id=""><a href="global.html#updateZoom">updateZoom</a></li></ul> </div></div>
      

    </nav>
    <div class="navbar-ham" id="navbar-ham">
      <div>
        <div class="first"></div>
        <div class="second"></div>
        <div class="third"></div>
      </div>
    </div>

    <div id="main" class="main-content">
      
      <h1 id='page-title' class="page-title">
        index.js
      </h1>
      

      



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>//import shallowEqual from 'shallowequal';
import { Model } from '@graphistry/falcor-model-rxjs';
import { PostMessageDataSource } from '@graphistry/falcor-socket-datasource';
import { $ref, $atom, $value } from '@graphistry/falcor-json-graph';
import {
    ajax,
    catchError,
    concatMap,
    delay,
    filter,
    forkJoin,
    fromEvent,
    isEmpty,
    //last,
    map,
    Observable,
    of,
    pipe,
    ReplaySubject,
    share,
    startWith,
    //Subject,
    switchMap,
    take,
    takeLast,
    tap,
    timer
} from './rxjs';  // abstract to simplify tolerating constant rxjs namespace manglings


// //////////////////////////////////////////////////////////////////////////////

    /**
     * @function makeCaller
     * @private
     * @description Serialization and coordination for formatting postMessage API calls, used with {@link GraphistryState} {@link Observable}s
     * @param {string} modelName - 'view' or 'workbook'
     * @param {any} args - anything to pass as falcor .call(...args)
     * @return {@link GraphistryState} {@link Observable} 
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *    .pipe(
     *          makeCaller('view', 'tick', []),
     *          delay(2000),
     *          makeCaller('view', 'tick', []))
     *    .subscribe();
     **/
    export function makeCaller(modelName, ...args) {
        return switchMap(g => {
            console.debug('makeCaller switchMap', {g});
            //Wrap in Observable to insulate from PostMessageDataSource's rxjs version of Observable
            return (new Observable((subscriber) => {
                console.debug('caller hit', modelName, args, {g});
                let runs = 0;
                const sub = g.models[modelName]
                    .call(...args)
                    .subscribe(
                        (x) => { 
                            runs++;
                            console.debug('caller tick', x, {runs});
                            subscriber.next(x);
                        },
                        (e) => {
                            runs++;
                            console.error('caller error', e, {runs});
                            subscriber.error(e);
                        },
                        () => { 
                            console.debug('caller complete', modelName, args, {runs});
                            subscriber.complete();
                        });
                return () => {
                    console.debug('caller unsub skip', modelName, args, {runs});
                    sub.unsubscribe();
                };
            }))            
            .pipe(
                tap(v => console.debug('caller got', modelName, args, v, {g})),
                map(v => g.updateStateWithResult(v)));
        });
    }

    /**
     * @function makeCallerJSON
     * @private
     * @description Serialization and coordination for formatting postMessage API calls, used with {@link GraphistryState} {@link Observable}s. Adds json desrialization to {@link makeCaller}.
     * @param {string} modelName - 'view' or 'workbook'
     * @param {any} args - anything to pass as falcor .call(...args)
     * @return {@link GraphistryState} {@link Observable} 
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *    .pipe(
     *          makeCaller('view', 'tick', []),
     *          delay(2000),
     *          makeCaller('view', 'tick', []))
     *    .subscribe();
     **/
    export function makeCallerJSON(modelName, ...args) {
        return switchMap(g => 
            of(g)
                .pipe(
                    makeCaller(modelName, ...args),
                    map(({ json }) => json.toJSON())));
    }


    /**
     * 
     * @function makeGetter
     * @description Serialization and coordination for formatting postMessage API calls, used with {@link GraphistryState} {@link Observable}
     * @param {string} modelName 
     * @param  {...any} args - anything to pass as falcor .get(...args)
     * @returns {@link GraphistryState} {@link Observable}
     */
    export function makeGetter(modelName, ...args) {
        return switchMap(g => {
            //Wrap in Observable to insulate from PostMessageDataSource's rxjs version of Observable
            return (new Observable((subscriber) => {
                console.debug('getter hit', modelName, args);
                const sub = g.models[modelName]
                    .get(...args)
                    .subscribe(
                        (x) => { subscriber.next(x); },
                        (e) => { subscriber.error(e); },
                        () => { 
                            console.debug('getter complete', modelName, args);
                            subscriber.complete();
                        });
                return () => {
                    console.debug('getter unsub', modelName, args);
                    sub.unsubscribe();
                };
            }))
            .pipe(
                tap(v => console.debug('getter got', modelName, args, v)),
                map(v => g.updateStateWithResult(v)));
        });
    }

    /**
     * @function makeGetterJSON
     * @description Serialization and coordination for formatting postMessage API calls, used with {@link GraphistryState} {@link Observable}. Adds json desrialization to {@link makeGetter}.
     * @param {string} modelName 
     * @param  {...any} args 
     * @returns {@link GraphistryState} {@link Observable}
     */
    export function makeGetterJSON(modelName, ...args) {
        return switchMap(g => 
            of(g)
                .pipe(
                    makeGetter(modelName, ...args)));
    }


    /*
    *       /*
        const { workbook } = this;
        return new this(workbook.get('id')
            .map(({ json }) => json.toJSON())
            .toPromise());
            */

    /**
     * @function makeSetterWithModel
     * @private
     * @description Serialization and coordination for formatting postMessage API calls, used with {@link GraphistryState} {@link Observable}s
     * @param {string} modelName - 'view' or 'workbook'
     * @param {string} value - {@link $value} path/value pair
     * @return {@link GraphistryState} {@link Observable} 
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *    .pipe(makeSetterWithModel('view', model => myValuesFromModel(model)))
     *    .subscribe();
     **/
    export function makeSetterWithModel(modelName, valuesFromModel) {
        return switchMap((g) => {
            const values = valuesFromModel(g.models[modelName]);
            const out = g.models[modelName].set(...values);
            //Wrap in Observable to insulate from PostMessageDataSource's rxjs version of Observable
            return (new Observable((subscriber) => {
                console.debug('starting makeSetterWithModel postMessage cmds', values);
                const sub = out.subscribe(
                    ((v) =>{ subscriber.next(v); }),
                    ((e) =>{ subscriber.error('iframe setter fail', e); }),
                    (() =>{ subscriber.complete(); }));
                return () => {
                    console.debug('finished makeSetterWithModel; unsubscribe postMessage', {sub, values});
                    sub.unsubscribe();
                };
            }))
                .pipe(
                    tap((v) => { console.debug('setter resp pre', v); }),
                    map(({ json }) => g.updateStateWithResult(json.toJSON())),
                    tap((v) => { console.debug('setter resp post', v); }))
        });
    }

    /**
     * @function makeSetter
     * @private
     * @description Serialization and coordination for formatting postMessage API calls, used with {@link GraphistryState} {@link Observable}s
     * @param {string} modelName - 'view' or 'workbook'
     * @param {string} value - {@link $value} path/value pair
     * @return {@link GraphistryState} {@link Observable} 
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *    .pipe(makeSetter('view', $value('viz.width', 500)))
     *    .subscribe();
     **/
    export function makeSetter(modelName, ...values) {
        return makeSetterWithModel(modelName, () => { return values; });
    }

// //////////////////////////////////////////////////////////////////////////////


    /*
    static _getIds(componentType, name, dataType, values = []) {
        const { view } = this;
        return new this(view
            .call(`componentsByType['${componentType}'].rows.filter`, [name, dataType, values], ['_index'])
            .takeLast(1)
            .map(({ json = {} }) => {
                const { componentsByType = {} } = json;
                const { [componentType]: componentsForType = {} } = componentsByType;
                const { rows = {} } = componentsForType;
                return Array
                    .from(rows.filter || [])
                    .filter(Boolean).map(({ _index }) => _index);
            })
            .toPromise()
        );
    }
}
*/

    /**
     * Add columns to the current graph visuzliation's dataset
     * GraphistryJS(document.getElementById('viz'))
     *     .flatMap(function(g) {
     *         window.g = g;
     *         const columns = [
     *             ['edge', 'highways', [66, 101, 280], 'number'],
     *             ['point', 'theme parks', ['six flags', 'disney world', 'great america'], 'string']
     *         ];
     *         console.log('adding columns', columns);
     *         return g.addColumns.apply(g, columns);
     *     })
     *     .subscribe();
     */
    /*
    Graphistry.addColumns = function (...columns) {
        const { view } = this;
        return new this(this
            .from(columns)
            .concatMap((column) => view.call('columns.add', column))
            .map(({ json: { columns }}) => columns).filter(Boolean)
            .map((columns) => columns[columns.length - 1].toJSON())
            .toArray()
            .toPromise()
        );
    }
    */


    /**
     * @function encodeColor
     * @description Change colors based on an attribute. Pass null for attribute, mapping to clear.
     * @param {GraphType} [graphType] - 'point' or 'edge'
     * @param {Attribute} [attribute] - name of data column, e.g., 'degree'
     * @param {Variant} [variation] - If there are more bins than colors, use 'categorical' to repeat colors and 'continuous' to interpolate
     * @param {any} [colorsOrMapping] - array of color name or hex codes, or object mapping
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodeColor('point', 'degree', 'categorical', ['black', 'white']))
     *     .subscribe();
     */
    export function encodeColor(graphType, attribute, variation, colorsOrMapping) {

        const colorDict = Array.isArray(colorsOrMapping) ? {colors: colorsOrMapping} : {mapping: colorsOrMapping};

        const value = $value(`encodings.${graphType}.color`,
        {   reset: attribute === undefined, variation, name: 'user_' + Math.random(),
            encodingType: 'color', graphType, attribute, ...colorDict });

        return makeSetter('view', value);
    }


    /**
     * @function encodePointColor
     * @description Single-argument version of {@link encodeColor} used for React props
     * @param {Array} array: undefined to reset; str to use directly; [str attr, 'categorical' or 'continuous', [ str ] or mapping]
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodePointColor())
     *     .subscribe();
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodePointColor('prebaked_colors_col'))
     *     .subscribe();
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodePointColor(['degree', 'categorical', ['black', 'white']]))
     *     .subscribe();
    **/
    export function encodePointColor(opts) {
        const args = ['point'];
        if (opts !== undefined) {
            if (opts instanceof Array) {
                for (let v of opts) {
                    args.push(v);
                }
            } else if (typeof(opts) === 'string') {
                args.push(opts);
            }
        }
        return encodeColor.apply(this, args);
    }

    /**
     * @function encodeEdgeColor
     * @description Single-argument version of {@link encodeColor} used for React props
     * @param {Array} array: undefined to reset; str to use directly; [str attr, 'categorical' or 'continuous', [ str ] or mapping]
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodeEdgeColor())
     *     .subscribe();
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodeEdgeColor('prebaked_colors_col'))
     *     .subscribe();
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodeEdgeColor(['degree', 'categorical', ['black', 'white']]))
     *     .subscribe();
    **/
    export function encodeEdgeColor (opts) {
        const args = ['edge'];
        if (opts !== undefined) {
            if (opts instanceof Array) {
                for (let v of opts) {
                    args.push(v);
                }
            } else if (typeof(opts) === 'string') {
                args.push(opts);
            }
        }
        return encodeColor.apply(this, args);
    }


    /**
     * @function encodeAxis
     * @description Add an axis to the graph
     * @param {Object}
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     */
     export function encodeAxis(axis) {
        const value = $value(`encodings.point.axis`,
        {   reset: axis === undefined, name: 'user_' + Math.random(),
            encodingType: 'axis', graphType: 'point', attribute: 'degree', variation: 'categorical',
            rows: axis });

        return makeSetter('view', value);
    }



    /**
     * @function encodeIcons
     * @description Change icons based on an attribute. Pass undefined for attribute, mapping to clear.
     * @param {GraphType} [graphType] - 'point' or 'edge'
     * @param {Attribute} [attribute] - name of data column, e.g., 'icon'
     * @param {Mapping} [object] - optional value mapping, e.g., {categorical: {fixed: {ip: 'laptop', alert: 'alaram'}, other: 'question'}}
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodeIcons('point', 'icon', 'some_attr'))
     *     .subscribe();
     **/
    export function encodeIcons(graphType, attribute, mapping) {
        const value = $value(`encodings.${graphType}.icon`,
        {   reset: attribute === undefined, name: 'user_' + Math.random(),
            encodingType: 'icon', graphType, attribute, mapping });
        return makeSetter('view', value);
    }


    /**
     * @function encodePointIcons
     * @description Single-argument point change icons based on an attribute for React props
     * @param {Array} array: undefined to reset; str to use directly; [str attr, mapping]
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodePointIcons())
     *     .subscribe();
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodePointIcons('some_attr'))
     *     .subscribe();
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodePointIcons(['some_attr', some_mapping]))
     *     .subscribe();
    **/
    export function encodePointIcons(opts) {
        const args = ['point'];
        if (opts !== undefined) {
            if (opts instanceof Array) {
                for (let v of opts) {
                    args.push(v);
                }
            } else if (typeof(opts) === 'string') {
                args.push(opts);
            }
        }
        return encodeIcons.apply(this, args);
    }

    /**
     * @function encodeEdgeIcons
     * @description Single-argument edge change icons based on an attribute for React props
     * @param {Array} array: undefined to reset; str to use directly; [str attr, mapping]
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodeEdgeIcons())
     *     .subscribe();
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodeEdgeIcons('some_attr'))
     *     .subscribe();
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodeEdgeIcons(['some_attr', some_mapping]))
     *     .subscribe();
    **/
     export function encodeEdgeIcons(opts) {
        const args = ['edge'];
        if (opts !== undefined) {
            if (opts instanceof Array) {
                for (let v of opts) {
                    args.push(v);
                }
            } else if (typeof(opts) === 'string') {
                args.push(opts);
            }
        }
        return encodeIcons.apply(this, args);
    }


    /**
     * @function encodeSize
     * @description Change size based on an attribute. Pass null for attribute, mapping to clear.
     * @param {GraphType} [graphType] - 'point'
     * @param {Attribute} [attribute] - name of data column, e.g., 'degree'
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodeSize('point', 'community_infomap'))
     *     .subscribe();
     */
     export function encodeSize(graphType, attribute, mapping) {
        const value = $value(`encodings.${graphType}.size`,
                {   reset: attribute === undefined, name: 'user_' + Math.random(),
                    encodingType: 'size', graphType, attribute, ...(mapping ? {mapping} : {}) });
        return makeSetter('view', value);
    }

    /**
     * @function encodePointSize
     * @description Single-argument point change size based on an attribute for React props
     * @param {Array} array: undefined to reset; str to use directly; [str attr, mapping]
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodePointSize())
     *     .subscribe();
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodePointSize('some_attr'))
     *     .subscribe();
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodePointSize(['some_attr', some_mapping]))
     *     .subscribe();
    **/
    export function encodePointSize(opts) {
        const args = ['point'];
        if (opts !== undefined) {
            const attribute = opts instanceof Array ? opts[0] : opts;
            args.push(attribute);
            if (opts instanceof Array &amp;&amp; opts.length > 1) {
                const mapping = opts[1];
                args.push(mapping);
            }
        }
        return encodeSize.apply(this, args);
    }


    /**
     * @function togglePanel
     * @description Toggle a top menu panel on/off. If panel is an array, interpret as [panel, turnOn]
     * @param {string} [panel] - Name of panel: filters, exclusions, scene, labels, layout
     * @param {boolean} [turnOn] - Whether to make panel visible, or turn all off
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(togglePanel('filters', true));
     *     .subscribe();
     */
     export function togglePanel(panel, turnOn) {
        if (Array.isArray(panel)) {
            turnOn = panel.length > 1 ? panel[1] : undefined;
            panel = panel[0];
        }
        if (turnOn) {
            return makeSetterWithModel('view', (view) => {
                const values = [
                    $value(`filters.controls[0].selected`, panel === 'filters'),
                    $value(`scene.controls[1].selected`, panel === 'scene'),
                    $value(`labels.controls[0].selected`, panel === 'labels'),
                    $value(`layout.controls[0].selected`, panel === 'layout'),
                    $value(`exclusions.controls[0].selected`, panel === 'exclusions'),
                    $value(`panels.left`,
                        panel === 'filters' ? $ref(view._path.concat(`filters`))
                        : panel === 'scene' ? $ref(view._path.concat(`scene`))
                        : panel === 'labels' ? $ref(view._path.concat(`labels`))
                        : panel === 'layout' ? $ref(view._path.concat(`layout`))
                        : $ref(view._path.concat(`exclusions`)))
                ];
                return values;
            });
        } else {
            const values = [
                $value(`panels.left`, undefined),
                $value(`filters.controls[0].selected`, false),
                $value(`scene.controls[1].selected`, false),
                $value(`labels.controls[0].selected`, false),
                $value(`layout.controls[0].selected`, false),
                $value(`exclusions.controls[0].selected`, false)
            ];
            return makeSetter('view', ...values);
        }
    }

    /**
     * @function encodeDefaultIcons
     * @description Change default (user-unset) icons based on an attribute. Pass undefined for attribute, mapping to clear.
     * @param {GraphType} [graphType] - 'point' or 'edge'
     * @param {Attribute} [attribute] - name of data column, e.g., 'icon'
     * @param {Mapping} [object] - optional value mapping, e.g., {categorical: {fixed: {ip: 'laptop', alert: 'alaram'}, other: 'question'}}
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodeDefaultIcons('point', 'icon', 'some_attr'))
     *     .subscribe();
     **/
    export function encodeDefaultIcons(graphType, attribute, mapping) {
        const value = $value(`encodings.defaults.${graphType}.icon`,
                {   reset: attribute === undefined, name: 'user_' + Math.random(),
                    encodingType: 'icon', graphType, attribute, mapping });
        return makeSetter('view', value);
    }

    /**
     * @function encodeDefaultPointIcons
     * @description Single-argument point default icons (user-unset) based on an attribute for React props
     * @param {Array} array: undefined to reset; str to use directly; [str attr, mapping]
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodeDefaultPointIcons())
     *     .subscribe();
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodeDefaultPointIcons('some_attr'))
     *     .subscribe();
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodeDefaultPointIcons(['some_attr', some_mapping]))
     *     .subscribe();
    **/
   export function encodeDefaultPointIcons(opts) {
        const args = ['point'];
        if (opts !== undefined) {
            const attribute = opts instanceof Array ? opts[0] : opts;
            args.push(attribute);
            if (opts instanceof Array &amp;&amp; opts.length > 1) {
                const mapping = opts[1];
                args.push(mapping);
            }
        }
        return encodeDefaultIcons.apply(this, args);
    }

    /**
     * @function encodeDefaultEdgeIcons
     * @description Single-argument edge default icons (user-unset) based on an attribute for React props
     * @param {Array} array: undefined to reset; str to use directly; [str attr, mapping]
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodeDefaultEdgeIcons())
     *     .subscribe();
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodeDefaultEdgeIcons('some_attr'))
     *     .subscribe();
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(encodeDefaultEdgeIcons(['some_attr', some_mapping]))
     *     .subscribe();
    **/
   export function encodeDefaultEdgeIcons(opts) {
        const args = ['edge'];
        if (opts !== undefined) {
            const attribute = opts instanceof Array ? opts[0] : opts;
            args.push(attribute);
            if (opts instanceof Array &amp;&amp; opts.length > 1) {
                const mapping = opts[1];
                args.push(mapping);
            }
        }
        return encodeDefaultIcons.apply(this, args);
    }

    export function encodeDefaultSize(graphType, attribute, mapping) {
        const { view } = this;
        return new this(view.set(
            $value(`encodings.defaults.${graphType}.size`,
                {   reset: attribute === undefined, name: 'user_' + Math.random(),
                    encodingType: 'size', graphType, attribute, mapping }))
            .map(({ json }) => json.toJSON())
            .toPromise());
    }

    export function encodeDefaultPointSize(opts) {
        const args = ['point'];
        if (opts !== undefined) {
            const attribute = opts instanceof Array ? opts[0] : opts;
            args.push(attribute);
            if (opts instanceof Array &amp;&amp; opts.length > 1) {
                const mapping = opts[1];
                args.push(mapping);
            }
        }
        return encodeDefaultSize.apply(this, args);
    }

    export function encodeDefaultEdgeSize(opts) {
        const args = ['edge'];
        if (opts !== undefined) {
            const attribute = opts instanceof Array ? opts[0] : opts;
            args.push(attribute);
            if (opts instanceof Array &amp;&amp; opts.length > 1) {
                const mapping = opts[1];
                args.push(mapping);
            }
        }
        return encodeDefaultSize.apply(this, args);
    }

    export function encodeDefaultColor(graphType, attribute, variation, mapping) {
        const value = $value(`encodings.defaults.${graphType}.color`,
                {   reset: attribute === undefined, variation, name: 'user_' + Math.random(),
                    encodingType: 'color', graphType, attribute, mapping });
        return makeSetter('view', value);
    }  

    export function encodeDefaultPointColor(opts) {
        const args = ['point'];
        if (opts !== undefined) {
            const attribute = opts instanceof Array ? opts[0] : opts;
            args.push(attribute);
            if (opts instanceof Array &amp;&amp; opts.length > 1) {
                const mapping = opts[1];
                args.push(mapping);
            }
        }
        return encodeDefaultColor.apply(this, args);
    }

    export function encodeDefaultEdgeColor(opts) {
        const args = ['edge'];
        if (opts !== undefined) {
            const attribute = opts instanceof Array ? opts[0] : opts;
            args.push(attribute);
            if (opts instanceof Array &amp;&amp; opts.length > 1) {
                const mapping = opts[1];
                args.push(mapping);
            }
        }
        return encodeDefaultColor.apply(this, args);
    }

    /**
     * @function toggleInspector
     * @description Toggle inspector panel
     * @param {boolean} [turnOn] - Whether to make panel visible
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(toggleInspector(true))
     *     .subscribe();
     */
     export function toggleInspector(turnOn) {
        if (!turnOn) {
            const values = [
                $value(`panels.bottom`, undefined),
                $value(`inspector.controls[0].selected`, false)
            ];
            return makeSetter('view', ...values);
        } else {
            return makeSetterWithModel('view', (view => {
                const values = [
                    $value(`inspector.controls[0].selected`, true),
                    $value(`panels.bottom`, $ref(view._path.concat(`inspector`)))
                ];
                return values;
            }));
        }
    }

    /**
     * @function toggleTimebars
     * @description Toggle timebars panel
     * @param {boolean} [turnOn] - Whether to make panel visible
     * @return {@link Graphistry} A {@link Graphistry} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(toggleTimebars(true));
     *     .subscribe();
     */
     export function toggleTimebars(turnOn) {
        if (!turnOn) {
            const values = [
                $value(`panels.bottom`, undefined),
                $value(`timebars.controls[0].selected`, false)
            ];
            return makeSetter('view', ...values);
        } else {
            return makeSetterWithModel('view', (view => {
                const values = [
                    $value(`timebars.controls[0].selected`, true),
                    $value(`panels.bottom`, $ref(view._path.concat(`timebars`)))
                ];
                return values;
            }));
        }
    }

    /**
     * @function toggleHistograms
     * @description Toggle histogram panel
     * @param {boolean} [turnOn] - Whether to make panel visible
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     *  GraphistryJS(document.getElementById('viz'))
     *     .pipe(toggleHistograms(true))
     *     .subscribe();
     */
     export function toggleHistograms(turnOn) {
        return makeSetterWithModel('view', (view => {
            if (!turnOn) {
                return [
                    $value(`panels.right`, undefined),
                    $value(`histograms.controls[0].selected`, false)
                ];
            } else {
                return [
                    $value(`histograms.controls[0].selected`, true),
                    $value(`panels.right`, $ref(view._path.concat(`histograms`)))
                ];
            }
        }));
    }

    /**
     * @function Graphistry.tickClustering
     * @description Run a number of steps of Graphistry's clustering algorithm
     * @param {number} ticks - The number of ticks to run
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *     .pipe(tickClustering())
     *     .subscribe();
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *     .pipe(tickClustering(10))
     *     .subscribe();
     */
     export function tickClustering(/*ticks = 1*/) {

        throw new Error('Not implemented');
        /*

        console.debug('tickClustering', {ticks});

        if (typeof ticks !== 'number') {
            return map(g => g);
        }
        return switchMap(g => {
            return (
                timer(0, 40)
                .pipe(
                    tap((v) => console.debug('tick', v, g)),
                    take(Math.abs(ticks) || 1),
                    tap((v) => console.debug('tick b', v, g)),
                    map(() => g),
                    makeCaller('view', 'tick', [{}]),
                    isEmpty(),
                    tap((v) => console.debug('tick result', v, g)),
                    takeLast(1)
                ));
        });
        */
    }

    /**
     * Center the view of the graph
     * @function autocenter
     * @todo Implement this function
     * @static
     * @param {number} percentile - Controls sensitivity to outliers
     * @param {function} [cb] - Callback function of type callback(error, result)
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *     .pipe(autocenter(.90))
     *     .subscribe();
     */
     export function autocenter(percentile) {
        return makeCallerJSON('view', 'autocenter', [percentile]);
    }

    /**
     * Read the workbook ID
     * @function getCurrentWorkbook
     * @param {function} [cb] - Callback function of type callback(error, result)
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *     .pipe(getCurrentWorkbook())
     *     .subscribe(function (workbook) {
     *         alert('id: ' + workbook.id)
     *     });
     */
    export function getCurrentWorkbook () {
        return makeGetterJSON('workbook', 'id');
    }

    /**
     * Save the current workbook. A saved workbook will persist the analytics state
     * of the visualization, including active filters and exclusions
     * @function saveWorkbook
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *     .pipe(saveWorkbook())
     *     .subscribe();
     */
     export function saveWorkbook() {
        return makeCallerJSON('workbook', 'save', []);
    }


    /**
     * Hide or Show Toolbar UI
     * @function toogleToolbar
     * @param {boolean} show - Set to true to show toolbar, and false to hide toolbar.
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     *
     * &lt;button onclick="g.pipe(toggleToolbar(false)).subcribe()">Hide toolbar&lt;/button>
     * &lt;button onclick="g.pipe(toggleToolbar(true)).subscribe()">Show toolbar&lt;/button>
     *
     */
     export function toggleToolbar(show) {
        return updateSetting('showToolbar', !!show);
    }

    /**
     * Add a filter to the visualization with the given expression
     * @function addFilter
     * @param {string} expr - An expression using the same language as our in-tool
     * exclusion and filter panel
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *     .pipe(
     *          addFilter('point:degree > 0'),
     *          addFilter('edge:value > 0'))
     *     .subscribe();
     */
    export function addFilter(expr) {
        return makeCaller('view', 'filters.add', [expr]);
    }

    /**
     * Add filters to the visualization with the given expression
     * @function addFilter
     * @param {array} expr - An array of expressions using the same language as our in-tool
     * exclusion and filter panel
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *     .pipe(addFilters(['point:degree > 0', 'edge:value > 0'])));
     *     .subscribe();
     */
    export function addFilters(expr) {

        if (typeof(expr) === 'string') {
            return addFilter(expr);
        }

        if (!Array.isArray(expr)) {
            throw new Error('Expected an array of filters');
        }

        return switchMap(g => {
            return forkJoin(expr.map(e => of(g).pipe(addFilter(e))))
                .pipe(map((results) => g.updateStateWithResult(results)));
        });
    }

    /**
     * Add an exclusion to the visualization with the given expression
     * @function addExclusion
     * @param {string} expr - An expression using the same language as our in-tool
     * exclusion and filter panel
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *     .pipe(addExclusion('point:degree > 0'))
     *     .subscribe();
     */
     export function addExclusion(expr) {
        return makeCaller('view', 'exclusions.add', [expr]);
    }

    /**
     * Add an exclusion to the visualization with the given expression
     * @function addExclusions
     * @param {array} expr - Expressions using the same language as our in-tool
     * exclusion and filter panel
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *     .pipe(addExclusions(['point:degree > 0'], ['edge:value > 0']))
     *     .subscribe();
     */
    export function addExclusions(expr) {

        if (typeof(expr) === 'string') {
            return addExclusion(expr);
        }

        if (!Array.isArray(expr)) {
            throw new Error('Expected an array of exclusions');
        }

        return switchMap(g => {
            return forkJoin(expr.map(e => of(g).pipe(addExclusion(e))))
                .pipe(map((results) => g.updateStateWithResult(results)));
        });
    }

    const G_API_SETTINGS = {

        //models/toolbar.js
        'showToolbar': ['view', 'toolbar.visible'],

        //models/scene/scene.js
        'pruneOrphans': ['view', 'pruneOrphans'],
        'showArrows':   ['view', 'scene.renderer.showArrows'],
        'background':   ['view', 'scene.renderer.background.color'],
        'edgeOpacity':  ['view', 'scene.renderer.edges.opacity'],
        'edgeSize':     ['view', 'scene.renderer.edges.scaling'],
        'edgeCurvature': ['view', 'scene.renderer.edges.curvature'],
        'pointOpacity': ['view', 'scene.renderer.points.opacity'],
        'pointSize':    ['view', 'scene.renderer.points.scaling'],

        //models/camera.js
        'zoom':   ['view', 'camera.zoom'],
        'center': ['view', 'camera.center["x", "y", "z"]'],

        //models/label.js
        'labelOpacity':          ['view', 'labels.opacity'],
        'labelEnabled':          ['view', 'labels.enabled'],
        'labelPropertiesEnabled': ['view', 'labels.propertiesEnabled'],
        'labelPOI':              ['view', 'labels.poiEnabled'],
        'labelLabelPOI':              ['view', 'labels.poiLabelEnabled'],
        'labelPOIMax':           ['view', 'labels.poiMax'],
        'labelHighlightEnabled': ['view', 'labels.highlightEnabled'],
        'labelColor':            ['view', 'labels.foreground.color'],
        'labelBackground':       ['view', 'labels.background.color'],

        //models/layout.js
        'precisionVsSpeed': ['view', 'layout.options.forceatlas2barnes[0].value'],
        'gravity':          ['view', 'layout.options.forceatlas2barnes[1].value'],
        'scalingRatio':     ['view', 'layout.options.forceatlas2barnes[2].value'],
        'edgeInfluence':    ['view', 'layout.options.forceatlas2barnes[3].value'],
        'strongGravity':    ['view', 'layout.options.forceatlas2barnes[4].value'],
        'dissuadeHubs':     ['view', 'layout.options.forceatlas2barnes[5].value'],
        'linLog':           ['view', 'layout.options.forceatlas2barnes[6].value'],
        'lockedX':          ['view', 'layout.options.forceatlas2barnes[7].value'],
        'lockedY':          ['view', 'layout.options.forceatlas2barnes[8].value'],
        'lockedR':          ['view', 'layout.options.forceatlas2barnes[9].value'],
    };

    /**
     * @description
     * Modify a settings value in the visualization
     *
     * | Available Settings | Value Type |
     * | ------------------ | ---------- |
     * | `showToolbar` | `boolean` |
     * | `pruneOrphans` | `boolean` |
     * | `showArrows` | `boolean` |
     * | `background` | color as hex or rgba `string` |
     * | `edgeOpacity` | `number` (0 to 1) |
     * | `edgeSize` | `number` (0.1 to 10) |
     * | `edgeCurvature` | `number` (0.1 to 1) |
     * | `pointOpacity` | `number` (0 to 1) |
     * | `pointSize` | `number` (0.1 to 10) |
     * | `zoom` | `uint` |
     * | `center` | `const 0` |
     * | `labelOpacity` | `boolean` |
     * | `labelEnabled` | `boolean` |
     * | `labelPOI` | `boolean` |
     * | `labelLabelPOI` | `boolean` |
     * | `labelHighlightEnabled` | `boolean` |
     * | `labelColor` | color as hex or rgba `string` |
     * | `labelBackground` | color as hex or rgba `string` |
     * | `precisionVsSpeed` | `int` (-5 to +5) |
     * | `gravity` | `number` (0 to 10) |
     * | `scalingRatio` | `number` (0 to 10) |
     * | `edgeInfluence` | `number` (0 to 10) |
     * | `strongGravity` | `boolean` |
     * | `dissuadeHubs` | `boolean` | 
     * | `linLog` | `boolean` |
     * | `lockedX` | `boolean` | 
     * | `lockedY` | `boolean` | 
     * | `lockedR` | `boolean` | 
     * @function updateSetting
     * @param {string} name - the name of the setting to change
     * @param {string} val - the value to set the setting to.
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     * graphistryJS(document.getElementById('viz'))
     *     .pipe(updateSetting('background', 'red'))
     *     .subscribe();
     */
    export function updateSetting (name, val) {
        console.debug('updating setting called', {G_API_SETTINGS, name, val});
        if (G_API_SETTINGS[name] === undefined) {
            throw new Error(`Property "${name}" is not a valid setting, available are: ${Object.keys(G_API_SETTINGS).join(', ')}`);
        }
        const [modelType, path] = G_API_SETTINGS[name];

        const value = $value(path, $atom(val, { $timestamp: Date.now() }) );
        return makeSetter(modelType, value);
    }

    /**
     * Update the camera zoom level
     * @function updateZoom
     * @param {number} level - Controls how far to zoom in or out.
     * @return {@link GraphistryState} A {@link GraphistryState} {@link Observable} that emits the result of the operation
     * @example
     * graphistryJS(document.getElementById('viz'))
     *     .pipe(updateZoom(2), delay(2000), updateZoom(0.5))
     *     .subscribe();
     */
     export function updateZoom (level) {
        return updateSetting('zoom', level);
    }

    /**
     * Get or create an {@link Observable} stream of all label updates from the visualization.
     * &lt;p>
     * The {@link Observable} returned by this method emits inner Observables, where each
     * inner {@link Observable} is tied to the lifetime of the label for which it was created.
     * &lt;/p>&lt;p>
     * For each label rendered in the visualization, the {@link Observable} returned by this
     * method will create and emit a new inner {@link Observable}. The inner {@link Observable} will
     * emit events when the label changes. For example, if the user clicks on the label,
     * or the label changes position because of a pan/zoom, the inner {@link Observable} will
     * emit an event.
     * &lt;/p>&lt;p>
     * The inner {@link Observable} for a label will complete if the label is removed from the screen.
     * &lt;/p>&lt;p>
     * @function labelUpdates
     * @return {Observable&lt;Observable&lt;LabelEvent>>} An {@link Observable} of inner {Observables}, where each
     * inner {@link Observable} represents the lifetime of a label in the visualization.
     * @example
     * GraphistryJS(document.getElementById('viz'))
     *     .pipe(
     *          labelUpdates(),
     *          tap(({ id, tag, pageX, pageY }) => {
     *                 // prints messages like
     *                 // > 'Label 13 added at (200, 340)'
     *                 // > 'Label 74 updated at (750, 100)'
     *                 console.log(`Label ${id} ${tag} at (${pageX}, ${pageY})`);
     *          }),
     *          takeLast(1),
     *          tap(function ({ id, pageX, pageY }) {
     *                 console.log(`Label ${id} removed at (${pageX}, ${pageY})`);
     *          });
     *     })
     *     .subscribe();
     */
     export function labelUpdates() {
        throw new Error('labelUpdates not implemented');
        /*
        return this.labelsStream || (this.labelsStream = this
            .fromEvent(window, 'message')
            .pluck('data')
            .filter((data) => data &amp;&amp; data.type === 'labels-update')
            .multicast(() => new ReplaySubject(1))
            .let((connectable) => connectable.connect() &amp;&amp; connectable.refCount())
            .scan((memo, { labels, simulating, semanticZoomLevel }) => {

                labels = labels || [];
                const updates = [], newSources = [];
                const labelsById = Object.create(null);
                const nextSources = Object.create(null);
                const { sources, prevLabelsById } = memo;
                let idx = -1, len = labels.length, label;

                while (++idx &lt; len) {
                    let source;
                    label = labels[idx];
                    const { id } = label;

                    if (id in sources) {
                        source = sources[id];
                        delete sources[id];
                        if (memo.simulating !== simulating ||
                            memo.semanticZoomLevel !== semanticZoomLevel ||
                            !shallowEqual(prevLabelsById[id], label)) {
                            updates.push({ ...label, simulating, semanticZoomLevel, tag: 'updated' });
                        }
                    } else {
                        newSources.push(source = new ReplaySubject(1));
                        updates.push({ ...label, simulating, semanticZoomLevel, tag: 'added' });
                        source.key = id;
                    }

                    labelsById[id] = label;
                    nextSources[id] = source;
                }

                for (const id in sources) {
                    sources[id].complete();
                }

                idx = -1;
                len = updates.length;
                while (++idx &lt; len) {
                    label = updates[idx];
                    nextSources[label.id].next(label);
                }

                return {
                    newSources,
                    simulating,
                    semanticZoomLevel,
                    sources: nextSources,
                    prevLabelsById: labelsById
                };
            }, {
                newSources: [],
                sources: Object.create(null),
                prevLabelsById: Object.create(null),
            })
            .mergeMap(({ newSources }) => newSources)
        );
        */
    }

    /**
     * Subscribe to label change and exit events
     * @function subscribeLabels
     * @param {Object} - An Object with `onChange` and `onExit` callbacks
     * @return {Subscription} A {@link Subscription} that can be used to stop reacting to label updates
     */
     export function subscribeLabels({ onChange, onExit }) {
         throw new Error('subscribeLabels not implemented', onChange, onExit);
         /*
        return this.labelUpdates().mergeMap((group) => group
            .do((event) => onChange &amp;&amp; onChange(event))
            .takeLast(1)
            .do((event) => onExit &amp;&amp; onExit(event))
        )
        .subscribe();
        */
    }


class GraphistryState {
    
    constructor(iFrame, models, result) {
        this._iFrame = iFrame;
        this._models = models;
        this.result = result;
    }

    clone() {
        return new GraphistryState(this.iFrame, this.models, this.result);
    }

    get iFrame() {
        return this._iFrame;
    }

    get models() {
        return this._models;
    }

    get workbook() {
        return this.models.workbook;
    }

    get view() {
        return this.models.view;
    }

    updateStateWithResult(result) {
        const clone = this.clone();
        clone.result = result;
        return clone;
    }

}


/**
 * Function that wraps an IFrame as an {@link Observable} {@link GraphistryState} - other methods in this library can be piped with it
 * @func graphistryJS
 * @exports module:Graphistry
 * @param {Object} IFrame - An IFrame that hosts a Graphistry visualization.
 * @return {@link Graphistry}
 * @example
 *
 * &lt;iframe id="viz" src="https://hub.graphistry.com/graph/graph.html?dataset=Miserables" />
 * &lt;script>
 * document.addEventListener("DOMContentLoaded", function () {
 *
 *     graphistryJS(document.getElementById('viz'))
 *        .pipe(
 *           tap((g) => {
 *             console.log('iframe ready; opening filters, pausing, then adding columns');
 *             document.getElementById('controls').style.opacity=1.0);
 *             window.g = g;
 *           }),
 *           openFilters,
 *           delay(5000),
 *           switchMap((g) => {
 *             console.log('filters opened &amp; delayed; adding columns');
 *             const columns = [
 *                 ['edge', 'highways', [66, 101, 280], 'number'],
 *                 ['point', 'theme parks', ['six flags', 'disney world', 'great america'], 'string']
 *             ];
 *             return (
 *                  forkJoin(columns.map(([type, name, values, type]) => addColumn(type, name, values, type)))
 *                  .pipe(map(() => g)))
 *        })
 *        .subscribe(
 *            (g) => { console.log('event', g); },
 *            (err) => { console.log('error', err); },
 *           () => { console.log('all done'); }
*         });
 * &lt;/script>
 *
 */
function graphistryJS(iFrame) {

    if (!iFrame) {
        throw new Error('No iframe provided to Graphistry');
    }

    console.debug('init graphistryJS', {iFrame, fromEvent, updateSetting, ajax});

    const flow = (
        fromEvent(iFrame, 'load')
        .pipe(
            tap((v) => { console.debug('Starting iframe protocol listen flow: Load trigger'), v }),
            startWith(iFrame),
            filter(target => target &amp;&amp; target.contentWindow &amp;&amp; target.contentWindow.postMessage),
            map(target => target.contentWindow),
            tap((target) => {
                console.info(`Graphistry API: connecting to client`, target.contentWindow);
                target.postMessage({type: 'ready', agent: 'graphistryjs'}, '*');
            }),
            switchMap(
                ((target) => 
                    fromEvent(window, 'message') //FIXME why not target? how to ensure proper frame?
                    .pipe(
                        filter(({ data, cache, ...rest }) => {
                            if (data &amp;&amp; data.type === 'init') {
                                console.debug('received valid postMessage handshake', {data, cache, rest});
                                return true;
                            } else {
                                console.debug('received irrelevant postMessage handshake', {data, cache, rest});
                                return false;
                            }
                        }),
                        map(({ data: { cache }, cache: cache2 }) => ({ target, cache, cache2 }))))),
            switchMap(({ target, cache, cache2 }) => {

                console.debug('Graphistry API: init filter passed, handling', {target, cache, cache2});

                //Observable wrapper insulating from Model's rxjs version
                // ... assume just new/get/subscribe/unsubscribe
                const model = new Model({
                    cache: cache || cache2 || {},
                    recycleJSON: true,
                    //scheduler: Scheduler.async, //TODO use default?
                    allowFromWhenceYouCame: true
                });
                model._source = new PostMessageDataSource(window, target, model, '*');
                return (new Observable((subscriber) => {
                    const sub = model.get(`workbooks.open.views.current.id`)
                        .subscribe(
                            (result) => { subscriber.next(result); },
                            (error) => { subscriber.error('iframe model initialization error', error); },
                            () => {
                                console.debug('PostMessageDataSource: teardown');
                                subscriber.complete();
                            });
                    return () => { sub.unsubscribe(); };
                }))
                    .pipe(
                        map(({ json, ...rest }) => {
                            console.debug('got postMessage model hit', json, rest)
                            const workbook = model.deref(json.workbooks.open);
                            const view = model.deref(json.workbooks.open.views.current);
                            console.debug(`PostMessageDataSource: connected to client`, { workbook, view });
                            return { workbook, view };
                        }),
                        map(({ workbook, view }) => new GraphistryState(iFrame, {model, view, workbook})),
                        tap((result) => {
                            console.info(`Graphistry API: connected to client`, result)
                        }));
            }),
            tap((result) => {
                console.debug(`Graphistry API (pre-replay): connected to client`, result)
            })
    ));

    //https://rxjs.dev/deprecations/multicasting
    const resubscribable = 
        flow.pipe(
            share({
                connector: () => new ReplaySubject(1),
                resetOnError: false,
                resetOnComplete: false,
                resetOnRefCountZero: false,
            }),
            tap((result) => { console.debug(`Graphistry API (replay): connected to client`, result) }),
    );

    return resubscribable;
}


//https://github.com/evanw/esbuild/issues/1719
//export default graphistryJS;

export {

    //main
    graphistryJS,

    //rxjs: reexport for end-user convenience without explicit dependency / rxjs expertise
    ajax,
    catchError,
    concatMap,
    delay,
    filter,
    forkJoin,
    isEmpty,
    Observable,
    of,
    map,
    pipe,
    startWith,
    switchMap,
    take,
    takeLast,
    tap,
    timer
    
    //g api
    //updateSetting, // exported upon definition
};

try {
    //backward compatibility
    window.GraphistryJS = graphistryJS;
} catch (e) {
    //not browser
}
</code></pre>
        </article>
    </section>




    </div>

    <footer class="footer" id="footer">
      
    </footer>

    <script src="scripts/third-party/prettify.js"></script>
    <script src="scripts/third-party/lang-css.js"></script>
    <script type="text/javascript" src="scripts/misc.js"></script>

    <script>prettyPrint();</script>
    <script src="scripts/linenumber.js"></script>
    <script src="scripts/fix-code-block.js"></script>
    <script src="scripts/fix-navbar.js"></script>
    
      <script src="scripts/search.js"></script>
      <script src="scripts/third-party/fuse.js"></script>
      <script>
        var list = [{"title":"graphistryJS","link":"<a href=\"module-graphistryJS.html\">graphistryJS</a>"},{"title":"addExclusion","link":"<a href=\"global.html#addExclusion\">addExclusion</a>"},{"title":"addExclusions","link":"<a href=\"global.html#addExclusions\">addExclusions</a>"},{"title":"addFilter","link":"<a href=\"global.html#addFilter\">addFilter</a>"},{"title":"autocenter","link":"<a href=\"global.html\">autocenter</a>"},{"title":"encodeAxis","link":"<a href=\"global.html#encodeAxis\">encodeAxis</a>"},{"title":"encodeColor","link":"<a href=\"global.html#encodeColor\">encodeColor</a>"},{"title":"encodeDefaultEdgeIcons","link":"<a href=\"global.html#encodeDefaultEdgeIcons\">encodeDefaultEdgeIcons</a>"},{"title":"encodeDefaultIcons","link":"<a href=\"global.html#encodeDefaultIcons\">encodeDefaultIcons</a>"},{"title":"encodeDefaultPointIcons","link":"<a href=\"global.html#encodeDefaultPointIcons\">encodeDefaultPointIcons</a>"},{"title":"encodeEdgeColor","link":"<a href=\"global.html#encodeEdgeColor\">encodeEdgeColor</a>"},{"title":"encodeEdgeIcons","link":"<a href=\"global.html#encodeEdgeIcons\">encodeEdgeIcons</a>"},{"title":"encodeIcons","link":"<a href=\"global.html#encodeIcons\">encodeIcons</a>"},{"title":"encodePointColor","link":"<a href=\"global.html#encodePointColor\">encodePointColor</a>"},{"title":"encodePointIcons","link":"<a href=\"global.html#encodePointIcons\">encodePointIcons</a>"},{"title":"encodePointSize","link":"<a href=\"global.html#encodePointSize\">encodePointSize</a>"},{"title":"encodeSize","link":"<a href=\"global.html#encodeSize\">encodeSize</a>"},{"title":"getCurrentWorkbook","link":"<a href=\"global.html#getCurrentWorkbook\">getCurrentWorkbook</a>"},{"title":"labelUpdates","link":"<a href=\"global.html#labelUpdates\">labelUpdates</a>"},{"title":"makeCaller","link":"<a href=\"global.html#makeCaller\">makeCaller</a>"},{"title":"makeCallerJSON","link":"<a href=\"global.html#makeCallerJSON\">makeCallerJSON</a>"},{"title":"makeGetter","link":"<a href=\"global.html#makeGetter\">makeGetter</a>"},{"title":"makeGetterJSON","link":"<a href=\"global.html#makeGetterJSON\">makeGetterJSON</a>"},{"title":"makeSetter","link":"<a href=\"global.html#makeSetter\">makeSetter</a>"},{"title":"makeSetterWithModel","link":"<a href=\"global.html#makeSetterWithModel\">makeSetterWithModel</a>"},{"title":"saveWorkbook","link":"<a href=\"global.html#saveWorkbook\">saveWorkbook</a>"},{"title":"subscribeLabels","link":"<a href=\"global.html#subscribeLabels\">subscribeLabels</a>"},{"title":"toggleHistograms","link":"<a href=\"global.html#toggleHistograms\">toggleHistograms</a>"},{"title":"toggleInspector","link":"<a href=\"global.html#toggleInspector\">toggleInspector</a>"},{"title":"togglePanel","link":"<a href=\"global.html#togglePanel\">togglePanel</a>"},{"title":"toggleTimebars","link":"<a href=\"global.html#toggleTimebars\">toggleTimebars</a>"},{"title":"toogleToolbar","link":"<a href=\"global.html#toogleToolbar\">toogleToolbar</a>"},{"title":"updateSetting","link":"<a href=\"global.html#updateSetting\">updateSetting</a>"},{"title":"updateZoom","link":"<a href=\"global.html#updateZoom\">updateZoom</a>"}];
        var options = 
          setupSearch(list, options)
      </script>
    

    

    

    

    


  </body>

</html>
